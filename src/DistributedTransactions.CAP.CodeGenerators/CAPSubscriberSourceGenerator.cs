using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace NetCorePal.Extensions.DistributedTransactions.CAP.CodeGenerators
{
    [Generator]
    public class CAPSubscriberSourceGenerator : ISourceGenerator
    {
        public void Execute(GeneratorExecutionContext context)
        {
            context.AnalyzerConfigOptions.GlobalOptions.TryGetValue("build_property.RootNamespace",
                out var rootNamespace);
            if (rootNamespace == null)
            {
                return;
            }
            var compilation = context.Compilation;
            foreach (var syntaxTree in compilation.SyntaxTrees)
            {
                if (syntaxTree.TryGetText(out var sourceText) &&
                    !sourceText.ToString().Contains("IIntegrationEventHandle"))
                {
                    continue;
                }
                var semanticModel = compilation.GetSemanticModel(syntaxTree);
                if (semanticModel == null)
                {
                    continue;
                }

                var typeDeclarationSyntaxs =
                    syntaxTree.GetRoot().DescendantNodesAndSelf().OfType<TypeDeclarationSyntax>();
                foreach (var tds in typeDeclarationSyntaxs)
                {
                    var symbol = semanticModel.GetDeclaredSymbol(tds);
                    if (!(symbol is INamedTypeSymbol)) return;
                    INamedTypeSymbol namedTypeSymbol = (INamedTypeSymbol)symbol;
                    if (!namedTypeSymbol.IsImplicitClass && namedTypeSymbol.AllInterfaces.Any(p => p.Name == "IIntegrationEventHandle"))
                    {
                        Generate(context, namedTypeSymbol, rootNamespace);
                    }
                }
            }
        }

        private void Generate(GeneratorExecutionContext context, INamedTypeSymbol eventHandlerTypeSymbol, string rootNamespace)
        {
            string className = eventHandlerTypeSymbol.Name;
            var attr = eventHandlerTypeSymbol.GetAttributes().FirstOrDefault(p => p.AttributeClass!.Name == "IntegrationEventConsumerAttribute");
            var eventName = attr?.ConstructorArguments.FirstOrDefault().Value?.ToString();
            var groupName = attr?.NamedArguments.FirstOrDefault(p => p.Key == "GroupName").Value.Value?.ToString();
            //根据dbContextType继承的接口IIntegrationEventHandle<TIntegrationEvent> 推断出TIntegrationEvent类型
            var typeArgument = eventHandlerTypeSymbol.AllInterfaces.FirstOrDefault(p => p.Name == "IIntegrationEventHandle")?.TypeArguments.FirstOrDefault();
            string source = $@"// <auto-generated/>
using DotNetCore.CAP;
using {eventHandlerTypeSymbol.ContainingNamespace};
namespace {rootNamespace}.Subscribers
{{
    public class {className}AsyncSubscriber : ICapSubscribe
    {{
        readonly {className} _handler;

        public {className}AsyncSubscriber({className} handler)
        {{
            _handler = handler;
        }}

        [CapSubscribe(""{eventName}"", Group = ""{groupName}"")]
        public Task ProcessAsync({typeArgument?.ContainingNamespace}.{typeArgument?.Name} message, CancellationToken cancellationToken)
        {{
            return _handler.HandleAsync(message, cancellationToken);
        }}
    }}
}}
";
            context.AddSource($"{className}ValueConverterConfigure.g.cs", source);
        }


        public void Initialize(GeneratorInitializationContext context)
        {

        }
    }
}
